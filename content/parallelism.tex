% !TeX spellcheck = hu_HU
% !TeX encoding = UTF-8
\chapter{A párhuzamos feldolgozás}\label{ch:parallelism}


\section{Párhuzamos hardver}\label{sec:par-hw}

A számítástechnika fejlődése során a processzorok számítási kapacitásának növelése folyamatos kutatás és fejlesztés témája, mind akadémiai, mind ipari csoportok körében.
%Ez érthető, hiszen minél gyorsabb, jobb, erősebb egy processzor, annál nagyobb és komplexebb számításokat tudunk végrehajtani, adott időtartam alatt.
A soros végrehajtás azonban csak egy adott ideig képes az elvárt számítási gyorsulást elhozni, előbb-utóbb megvalósítási vagy egyszerűen fizikai akadályokba ütközik a fejlődés. 

% TODO CISC,RISC rövidítés
Első megtestesülése ennek problémának akkor adódott, amikor az 1980-as évek elején az addig exkluzívan használatos CISC rendszerű processzorok komplexitása miatt, nehézkessé vált azok költséghatékony megvalósítása \cite{patterson_case_1980}.
Ekkor kezdett a RISC architektúra kibontakozni, és ebben az időben jelentek meg a transzpúterek is.
Mind két irányzat a komplex processzor architektúrák egyszerűsítését vélte a megfelelő iránynak, amit felhasználva különböző eredményeket próbáltak elérni: költséghatékonyabb megvalósítás, egyszerűbb használat és mindezekhez kisebb méretű assembly instrukció készlet.

% TODO VLSI rövidítés
A transzpúterek elsődleges elve, hogy egy chipre sok alapvetően szükséges részét egy számítógépnek ráültessék, és ezzel egy közel saját magukban számításra képes egységeket kapjanak.
Ez lehetségesé vált az akkoriban megjelenő mikroelektronikai fejlődések segítségével: ún.\ VLSI besorolású integrációs technológia felhasználásával.
Ennek megfelelően, a kor addigi mikroprocesszorainak nehézkes beágyazhatóságához képest \cite{clark_microprocessor_1978} kiemelkedő módon, egy transzpúter egység használata megvalósítható volt nagy részben a kommunikációs portok illesztésével.
Ez a gondolatmenet lehetővé tette a transzpúterek számára, hogy könnyedén komponálható legyen más áramkörökkel, beleértve más transzpúter egységeket is. 
Ezt a tulajdonságokat felhasználva pedig könnyen megvalósíthatóvá vált egy nagy párhuzamos számítógép összeállítása az egyes transzpúter elemek összekapcsolásával, ami az egyes egységeket párhuzamos számításra volt képes kihasználni.

Ezen transzpúterek legelterjedtebb felhasználására a szuperszámítógépek kategóriájában került sor, ahol több különböző architektúrát képviselő rendszerben is megtalálhatóak voltak.
Nagy reményt fűztek az Inmos új H1 és az Intel iWarp rendszereihez, amelyek a jövő transzpúter alapú rendszereit és szupergépeit fogják elhozni. \cite{hey_supercomputing_1990} A nagy lendület és elképzelések ellenére, ahogy látható a XXX. ábrán, a 2000-es évekre--nagyságrendileg 10 év elteltével a hivatkozott cikkhez képest--a különféle gyártók konkrét RISC rendszerei szinte minden sajátos megvalósítást kiszorítottak a szuperszámítógépekből.
A RISC gépek sem uralkodtak azonban örökké: az Intel és AMD alapú rendszerek a sok különböző RISC processzor architektúra szinte mindegyikét teljesen eltüntették a szuperszámítógépek területéről, és a mai napig uralkodónak számítanak.


% TODO TOP500 chip technology ábra

Ez utóbbi folyamat kezdete nagyjából egybe esik a személyi számítógépekben látott processzor párhuzamosítás kezdetével, ahol az IBM PC leszármazott rendszerekben az Intel 8086-os processzorok leszármazottjai számítottak mindig is uralkodó (CISC) ISA-nak.
A 2004-es évre az x86 processzorok órajelfrekvenciájának növelése elérte azt a pontot, ahol már a processzor által termelt hő mennyisége nem volt kezelhető a legtöbb gyakorlati alkalmazási területen. \cite{fuller_future_2011}
Ennek megfelelően az asztali processzorok órajelfrekvenciájában, amelyik addig a pontig exponenciálisan növekedett, \cite[S.1 ábra]{fuller_future_2011} egy sokkal lassabb növekedést lehetett tapasztalni, és a nagy modern CISC gyártók (Intel, AMD) is megállították az addigi kutatásaikat \cite{smith_intel_2004} és elkezdtek a párhuzamos feldolgozás irányába fejleszteni személyi számítógépeken is.
Azóta, ahogy a futtatott szoftver egyre jobban kihasználta a párhuzamosítás lehetőségeit, a magszám egyre fontosabbá vált a PC környezetben, annyira, hogy a modern felső kategóriás x86 asztali processzorok akár 16 fizikai maggal is rendelkeznek.

\section{Párhuzamos szoftver}\label{sec:par-sw}

Pusztán a hardver párhuzamosítása nem elegendő a teljesen párhuzamos számítási kapacitás eléréséhez.

Vannak ugyan a hardver párhuzamosításában olyan megoldások, amelyek az egyszerű soros kód automatikus parallelizációját próbálják elérni nagyon alacsony szinten a processzorban: a szóméret növelése és a futószalagok (\foreignlanguage{english}{pipeline}) kihasználásával megjelenő szuper-skalár processzorok ezt valósítják meg.
Ezek felhasználása azonban nem teszi lehetővé a párhuzamos hardver teljes kihasználását: a szóméretet csak egy ideig lehetséges növelni, utána jelentéktelenné válik, mert a végrehajtott műveletek nagy része nem használná ki a túlméretezett regisztereket, a szuper-skalár processzorok pedig csak instrukció szinten tudnak párhuzamosítást megvalósítani, így a különféle egymásrahatások jelentősen hátráltatják a menet közbeni párhuzamosítási lehetőségeit.

Amire szükség van, hogy a programozó által írt kód magas szintjén párhuzamos algoritmusok legyenek megvalósítva, kihasználva a tényleges problémakör lehetőségeit, valamilyen olyan programozási nyelvben, amelyik támogatja, hogy annak végrehajtása több teljesen párhuzamos végrehajtó egységen, tényleg parallel történjen meg.
Ennek hiányában a tényleges számítás csak általános megoldásokkal, alacsony szinten párhuzamosítható, ami a specializált esetnél jóval rosszabb minőségű párhuzamosítást tud sok esetben elérni.
A probléma azonban, hogy ezt klasszikus soros nyelvekben igen nehezen lehetséges elérni, és még a mai napig sok extra figyelmet igényel.
Emiatt a hardver parallelizációja óta a hozzá tartozó szoftver párhuzamosítása is aktív kutatás témája.

%\subsection{Párhuzamosítási kategóriák}
%
%Egy adott program párhuzamosítását különböző kategóriákba lehetséges sorolni. 
%Ezek a kategóriák mind különböző sajátosságokkal rendelkeznek, így lehetséges egy adott algoritmus párhuzamosításához megfelelő eszközöket választani.
%
%Ebben a dolgozatban két tulajdonság szerinti mátrixba kerülnek  besorolásra, az alábbi definíciók szerint.
%Az egyik a párhuzamosítás szintje, miszerint mik azok az elemek, amelyek párhuzamosan futnak: CPU instrukciók, szálak, amelyek egy folyamat memóriaterében találhatóak, vagy teljesen külön folyamatok. Ezek lehetnek egy adott gépen, vagy folyamatonként különbözőn.
%A másik tulajdonság pedig, hogy a parallelizáció explicit vagy implicit történik.
%Explicit esetben a programkód jelentős változtatásokat kell, hogy tartalmazzon a soros megvalósításhoz, ahhoz, hogy a párhuzamosítás helyessége garantálva legyen, míg implicit esetben csak a legfeljebb a párhuzamosság igényét kell jelezni a programban, és az valamilyen automatikus háttérrendszer döntése szerint megtörténik közvetlen beavatkozás nélkül.
%Lehetséges az is, hogy sem a forrást, sem a fordított binárist sem kell módosítani, hanem teljesen automatikusan történik a párhuzamosításból szerzett gyorsulás, mint a szuper-skalár végrehajtás esetén, de ez csak ritkán valósítható meg.
%
%\begin{table}[hbt]
%	\label{tbl:par-categories}
%	\center\begin{tabular}{|l|c|c|}
%		\hline
%		& Implicit & Explicit \\
%		\hline
%		Folyamat-szintű & & fork(2), PVM, MPI \\
%		\hline
%		Szál-szintű & OpenMP, std::execution & std::thread \\
%		\hline
%		Instrukció-szintű & szóméret növelés, szuper-skalár CPU & \\
%		\hline
%	\end{tabular}
%\end{table}
%
%\subsection{Soros nyelvek párhuzamosítása}
%
%A párhuzamosítás lehetőségeinek bevezetése soros nyelvekben általában alacsony szintű primitívek segítségével történik, amelyeknek a használata extra figyelmet igényel, különben könnyedén lehet pattot (deadlock), livelockot, vagy kiéheztetést előidézni a rendszerbe, amelyek annak használhatatlanságát vagy hatékonyságát veszélyeztetik.
%
%Például a C++ nyelv, közös memóriás szál alapú környezetben biztosít párhuzamosítást a beépített std::thread, std::mutex, std::condition\_variable és hasonló elemekkel.
%Ezek párhuzamosítási primitívek, hiszen magukban egy--egy ilyen elem nem elegendő egy (érdemi) párhuzamos program megvalósítására, ezeknek valamilyen kombinációját kell alkalmazni, hogy a programok kihasználhassák a párhuzamosítás előnyeit.
%Emiatt ezeket az eszközöket könnyű nem megfelelően használni, és az előzőekben felsorolt problémák könnyen előidézhetőek.
%
%Ennek ellenére, egy szál szintű párhuzamosítás megvalósítása esetén, ezek az eszközök igazán rugalmasak, és a használt hardverből lehetséges az algoritmus manuális optimalizálásával a legtöbbet kihozni.

\subsection{Párhuzamos transzpúterek programozása}

% TODO: \cite the manual, CSP rövidítés, \cite CSP
\Aref{sec:par-hw}.~szekcióban említett transzpúterek eredetileg csak egy saját programozási nyelvel rendelkeztek, mielőtt különféle cégek az akkor népszerű soros C, Pascal és Fortran nyelvek párhuzamosítható verzióit nem készítették el.
Ezeknek a célja mind az volt, hogy lehetővé tegyék a párhuzamosítás megvalósítását magas szintű programkódból.
Ezekből a nyelvekből emelkedik ki az említett eredeti transzpúter nyelv, az occam.
Alapvető felépítése C.~A.~R.~Hoare CSP paradigmáján \cite{hoare_communicating_2004} alapul, ami lehetővé teszi számára, hogy a matematikai formalizmus erejét felhasználja egy magas szintű programozási nyelvben.
Alapvető elve, hogy a különböző folyamatok párhuzamosan futnak és hajtják végre a számításaikat, amikor pedig szükség van valamilyen kommunikációra, akkor egy két folyamat közötti csatornán (channel) keresztül valósítják ezt meg.
A csatorna biztosítja, hogy az egyes résztvevők megfelelően el tudják küldeni az adatot az egyik folyamatból a másikba, anélkül, hogy az megvalósítás alatt található kommunikációval kellene foglalkozni. 
Ezt felhasználva, relatív könnyedséggel lehetséges párhuzamos programokat megvalósítani.

A transzpúterek saját magukban tartalmazták a használt memóriájukat, így azt csak a konkrét transzpúteren futó kód tudta csak elérni.
Ennek megfelelően, a kölcsönös kizárással az adott csatorna felett, a kommunikáció helyesen tudott működni, mert fizikailag más folyamat nem fért hozzá az adott memóriához.
A csatorna helyes zárolását pedig a nyelv (occam esetében), vagy a használt ... biztosítja.

Az occam alternatívájaként a későbbiekben jelentek meg párhuzamosított klasszikus programozási nyelvek különféle gyártóktól, mint a Fortran és a C, amelyek lehetővé tették fordításukat párhuzamos transzpúter számítógépekre.

A transzpúter hardver bukásának ellenére az occam által használt CSP modell a mai napig megjelenik a gyakorlatban, hiszen a modern, alig 10 éves, Go nyelv is ezen alapuló elvet használ a párhuzamosítás megvalósítására. \cite{google_frequently_nodate}

A dolgozat témája, a Linda nyelv, pedig tekinthető egy általánosításnak a CSP formalizmus felett. % TODO cite generative comm in linda
Az általa biztosított nyelvi elemek képesek arra, hogy a CSP-ben leírt egyirányú kommunikációt megvalósítsák, így minden, amit CSP-ben le lehetett írni, azt Linda segítésével is le lehet.

%\subsection{Általános párhuzamosítás}
%
%Míg az occam, mint a transzpúterek párhuzamos nyelve hosszan tartó benyomást tett a számítástechnika világára, rajta kívül elérhetővé váltak más ideológiák a programok párhuzamosítására, amelyek nem a transzpúterek sajátosságait voltak hivatottak kihasználni.
%
%
%





